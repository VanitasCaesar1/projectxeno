---
import SkeletonLoader from "./ui/SkeletonLoader.astro";
import MediaCard from "./MediaCard.astro";

interface Props {
  id: string;
  title: string;
  type: "popular" | "trending" | "top_rated" | "recommended";
  mediaType: "movie" | "tv" | "book" | "anime" | "manga";
  query?: string;
  filters?: Record<string, any>;
  isActive?: boolean;
  class?: string;
  initialData?: SearchResult[];
}

interface SearchResult {
  id: string;
  title: string;
  type: "movie" | "tv" | "book" | "anime" | "manga";
  year?: number;
  poster?: string;
  description?: string;
  rating?: number;
  source: "tmdb" | "openlibrary" | "jikan";
}

const {
  id,
  title,
  type,
  mediaType,
  query = "",
  isActive = false,
  class: className = "",
  initialData = [],
} = Astro.props;
---

<div
  class={`content-section ${isActive ? "" : "hidden"} ${className}`}
  data-section={id}
  data-section-type={type}
  data-section-query={query}
  data-media-type={mediaType}
>
  <div class="section-header mb-4">
    <h2 class="text-xl font-semibold text-gray-900 dark:text-gray-100">
      {title}
    </h2>
  </div>

  <!-- Loading State -->
  <div class="section-loading">
    <SkeletonLoader variant="media-grid" count={8} />
  </div>

  <!-- Content Grid -->
  <div
    class={`section-grid grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 ${initialData.length > 0 ? "" : "hidden"}`}
  >
    {
      initialData.map((item) => (
        <MediaCard
          id={item.id}
          title={item.title}
          type={item.type}
          year={item.year}
          poster={item.poster}
          description={item.description}
          rating={item.rating}
          source={item.source}
          onAdd={true}
        />
      ))
    }
  </div>

  <!-- Error State -->
  <div class="section-error hidden">
    <div class="text-center py-12">
      <div class="text-gray-400 mb-4">
        <svg
          class="mx-auto h-12 w-12"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
      </div>
      <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100 mb-2">
        Failed to load content
      </h3>
      <p class="text-gray-500 dark:text-gray-400 mb-4">
        There was an error loading this section.
      </p>
      <button
        class="retry-section px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200"
        data-section={id}
      >
        Try Again
      </button>
    </div>
  </div>

  <!-- Empty State -->
  <div class="section-empty hidden">
    <div class="text-center py-12">
      <div class="text-gray-400 mb-4">
        <svg
          class="mx-auto h-12 w-12"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.29-1.009-5.824-2.562M15 6.306a7.962 7.962 0 00-6 0m6 0a7.962 7.962 0 016 2.292 8.05 8.05 0 01.671 3.402"
          ></path>
        </svg>
      </div>
      <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100 mb-2">
        No {title.toLowerCase()} found
      </h3>
      <p class="text-gray-500 dark:text-gray-400">
        Check back later for new content.
      </p>
    </div>
  </div>

  <!-- Infinite Scroll -->
  <div class="section-infinite-scroll">
    <!-- Import the enhanced InfiniteScroll component -->
    <div class="infinite-scroll-wrapper" data-section-id={id}>
      <!-- This will be populated by JavaScript with the InfiniteScroll component -->
    </div>
  </div>
</div>

<style>
  .skeleton-card {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }
</style>

<script>
  interface SearchResult {
    id: string;
    title: string;
    type: "movie" | "tv" | "book" | "anime" | "manga";
    year?: number;
    poster?: string;
    description?: string;
    rating?: number;
    source: "tmdb" | "openlibrary" | "jikan";
  }

  class ContentSection {
    private container: HTMLElement;
    private sectionId: string;
    private sectionType: string;
    private mediaType: string;
    private query: string;
    private currentPage: number = 1;
    private hasMore: boolean = true;
    private isLoading: boolean = false;
    private data: SearchResult[] = [];
    private loadStartTime: number = 0;
    private optimizer?: any; // MediaGridOptimizer instance

    constructor(container: HTMLElement) {
      this.container = container;
      this.sectionId = container.dataset.section || "";
      this.sectionType = container.dataset.sectionType || "";
      this.mediaType = container.dataset.mediaType || "";
      this.query = container.dataset.sectionQuery || "";
      this.init();
    }

    private async init() {
      this.setupEventListeners();

      // Initialize performance optimizer
      try {
        const { MediaGridOptimizer } = await import(
          "../lib/mediaGridOptimizations"
        );
        this.optimizer = new MediaGridOptimizer(this.container, this.mediaType);
      } catch (error) {
        console.warn("Failed to load MediaGridOptimizer:", error);
      }

      // Initialize performance monitor
      try {
        const { performanceMonitor } = await import(
          "../lib/performanceMonitor"
        );
        (window as any).performanceMonitor = performanceMonitor;
      } catch (error) {
        console.warn("Failed to load PerformanceMonitor:", error);
      }

      // Load initial data if not already present
      const grid = this.container.querySelector(".section-grid");
      if (grid && grid.children.length === 0) {
        this.loadContent();
      }
    }

    private setupEventListeners() {
      // Retry button
      const retryBtn = this.container.querySelector(".retry-section");
      if (retryBtn) {
        retryBtn.addEventListener("click", () => this.retryLoad());
      }

      // Load more button
      const loadMoreBtn = this.container.querySelector(".load-more-btn");
      if (loadMoreBtn) {
        loadMoreBtn.addEventListener("click", () => this.loadMore());
      }

      // Section activation event
      this.container.addEventListener("sectionActivated", (e) => {
        const event = e as CustomEvent;
        if (event.detail.sectionId === this.sectionId) {
          this.loadContent();
        }
      });

      // Set up global function for load more
      (window as any)[`loadMoreSection_${this.sectionId}`] = () => {
        this.loadMore();
      };
    }

    public async loadContent(page: number = 1) {
      if (this.isLoading) return;

      // Handle recommended content differently
      if (this.sectionType === "recommended") {
        return this.loadRecommendations();
      }

      this.isLoading = true;
      this.loadStartTime = performance.now();
      this.showLoading(true);
      this.hideError();

      // Performance monitoring
      const timerName = `loadContent_${this.sectionId}_${page}`;
      if (window.performanceMonitor) {
        window.performanceMonitor.startTimer(timerName);
      }

      let results: SearchResult[] = [];

      try {
        const searchParams = new URLSearchParams({
          q: this.getQueryForType(),
          type: this.mediaType,
          page: page.toString(),
        });

        // Add specific parameters based on section type
        switch (this.sectionType) {
          case "top_rated":
            searchParams.append("sortBy", "rating");
            searchParams.append("sortOrder", "desc");
            searchParams.append("ratingFrom", "7.0");
            break;
          case "popular":
            searchParams.append("sortBy", "popularity");
            searchParams.append("sortOrder", "desc");
            break;
          case "trending":
            searchParams.append("sortBy", "rating");
            searchParams.append("sortOrder", "desc");
            searchParams.append("ratingFrom", "6.0");
            break;
        }

        // Use cached fetch for better performance
        const cacheKey = `section_${this.sectionId}_${this.mediaType}_${page}_${this.sectionType}`;
        let data;

        if (window.cachedFetch) {
          data = await window.cachedFetch(
            cacheKey,
            async () => {
              const response = await fetch(`/api/search?${searchParams}`);
              return response.json();
            },
            300
          ); // 5 minute cache
        } else {
          const response = await fetch(`/api/search?${searchParams}`);
          data = await response.json();
        }

        if (data.success) {
          results = data.data.results || [];

          if (page === 1) {
            this.data = results;
            this.displayContent(results);
          } else {
            this.data = [...this.data, ...results];
            this.appendContent(results);
          }

          this.currentPage = page;
          this.hasMore = page < (data.data.totalPages || 1);
          this.updateInfiniteScroll();

          // Update optimizer state
          if (this.optimizer) {
            this.optimizer.updateState({
              currentPage: this.currentPage,
              hasMore: this.hasMore,
              totalItems: this.data.length,
            });
            this.optimizer.observeItems();
          }
        } else {
          throw new Error(data.error?.message || "Failed to load content");
        }
      } catch (error) {
        console.error("Content loading error:", error);
        this.showError(
          error instanceof Error ? error.message : "Failed to load content"
        );
      } finally {
        this.isLoading = false;
        this.showLoading(false);

        // Performance monitoring
        if (window.performanceMonitor) {
          const duration = window.performanceMonitor.endTimer(timerName);
          window.performanceMonitor.recordContentLoad(
            this.sectionId,
            page,
            duration,
            results.length
          );
        }
      }
    }

    public async loadRecommendations() {
      if (this.isLoading) return;

      this.isLoading = true;
      this.showLoading(true);
      this.hideError();

      try {
        // Check if user is logged in by looking for auth cookies
        const hasAuth = document.cookie.includes('sb-access-token');
        
        if (!hasAuth) {
          // Show login prompt for recommendations
          this.showLoginPrompt();
          return;
        }

        const response = await fetch(
          `/api/user/recommendations?type=personalized&limit=20`
        );
        const data = await response.json();

        if (data.success) {
          const recommendations = data.data || [];

          // Filter by media type if specified
          const filteredRecommendations = this.mediaType === 'all' 
            ? recommendations 
            : recommendations.filter((item: any) => item.media_type === this.mediaType);

          // Convert to SearchResult format
          const results: SearchResult[] = filteredRecommendations.map(
            (item: any) => ({
              id: `rec-${item.id}`,
              title: item.title,
              type: item.media_type,
              year: item.release_date
                ? new Date(item.release_date).getFullYear()
                : undefined,
              poster: item.poster_url,
              description: item.description,
              rating: item.average_rating,
              source: "tmdb" as const,
            })
          );

          this.data = results;
          this.displayContent(results);
          this.hasMore = false; // Recommendations don't have pagination
          this.updateInfiniteScroll();
        } else if (data.error?.code === 'UNAUTHORIZED') {
          this.showLoginPrompt();
        } else {
          throw new Error(
            data.error?.message || "Failed to load recommendations"
          );
        }
      } catch (error) {
        console.error("Recommendations loading error:", error);
        
        // Check if it's an auth error
        if (error instanceof Error && error.message.includes('401')) {
          this.showLoginPrompt();
        } else {
          this.showError(
            error instanceof Error
              ? error.message
              : "Failed to load recommendations"
          );
        }
      } finally {
        this.isLoading = false;
        this.showLoading(false);
      }
    }

    private getQueryForType(): string {
      if (this.query) return this.query;

      // Default queries based on section type and media type
      const queries = {
        popular: {
          movie: "popular",
          tv: "popular",
          book: "bestseller",
          anime: "popular",
          manga: "popular",
        },
        trending: {
          movie: "trending",
          tv: "trending",
          book: "new release",
          anime: "trending",
          manga: "trending",
        },
        top_rated: {
          movie: "top rated",
          tv: "top rated",
          book: "award winning",
          anime: "top rated",
          manga: "top rated",
        },
      };

      const typeQueries = queries[this.sectionType as keyof typeof queries];
      return (
        typeQueries?.[this.mediaType as keyof typeof typeQueries] || "popular"
      );
    }

    private displayContent(results: SearchResult[]) {
      const grid = this.container.querySelector(".section-grid");
      if (!grid) return;

      grid.innerHTML = "";

      if (results.length === 0) {
        this.showEmpty();
        return;
      }

      results.forEach((result) => {
        const cardElement = this.createMediaCardElement(result);
        grid.appendChild(cardElement);
      });

      this.showGrid();
      this.hideEmpty();
    }

    private appendContent(results: SearchResult[]) {
      const grid = this.container.querySelector(".section-grid");
      if (!grid) return;

      // Performance optimization: batch DOM updates
      const fragment = document.createDocumentFragment();

      results.forEach((result) => {
        const cardElement = this.createMediaCardElement(result);
        cardElement.classList.add("new-content");
        fragment.appendChild(cardElement);
      });

      // Single DOM update
      grid.appendChild(fragment);

      // Trigger lazy loading for new images
      if (
        window.observeLazyImages &&
        typeof window.observeLazyImages === "function"
      ) {
        const observeLazyImages = window.observeLazyImages;
        if (typeof requestIdleCallback === "function") {
          requestIdleCallback(() => {
            observeLazyImages();
          });
        } else {
          // Fallback for browsers that don't support requestIdleCallback
          setTimeout(() => {
            observeLazyImages();
          }, 0);
        }
      }

      // Smooth scroll to new content after a brief delay
      setTimeout(() => {
        if (
          window.scrollToNewContent &&
          typeof window.scrollToNewContent === "function"
        ) {
          window.scrollToNewContent();
        }
      }, 100);

      // Performance monitoring
      if (window.performanceMonitor) {
        const loadDuration = performance.now() - (this.loadStartTime || 0);
        window.performanceMonitor.recordInfiniteScrollLoad(
          this.sectionId,
          loadDuration,
          results.length
        );
      }
    }

    private createMediaCardElement(result: SearchResult): HTMLElement {
      const cardDiv = document.createElement("div");
      cardDiv.className = "media-card-wrapper";
      cardDiv.setAttribute("data-item-id", result.id);

      const typeColors = {
        movie: "bg-blue-100 text-blue-800",
        tv: "bg-purple-100 text-purple-800",
        book: "bg-green-100 text-green-800",
        anime: "bg-orange-100 text-orange-800",
        manga: "bg-pink-100 text-pink-800",
      };

      const typeLabels = {
        movie: "Movie",
        tv: "TV Show",
        book: "Book",
        anime: "Anime",
        manga: "Manga",
      };

      cardDiv.innerHTML = `
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow duration-200 group">
          <div class="flex flex-col sm:flex-row">
            <div class="w-full h-48 sm:w-24 sm:h-36 flex-shrink-0 cursor-pointer lazy-image-container" onclick="window.location.href='/media/${result.type}/${result.id}'">
              <img 
                data-src="${result.poster || "/favicon.svg"}"
                src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='450' viewBox='0 0 300 450'%3E%3Crect width='300' height='450' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='system-ui' font-size='16' fill='%236b7280'%3ELoading...%3C/text%3E%3C/svg%3E"
                alt="${result.title} poster"
                class="lazy-image w-full h-full object-cover sm:rounded-l-lg rounded-t-lg sm:rounded-t-none transition-opacity duration-300"
                style="opacity: 0;"
                loading="lazy"
                onerror="this.src='/favicon.svg'; this.style.opacity='1';"
              />
            </div>
            <div class="flex-1 p-3 sm:p-4">
              <div class="flex items-start justify-between mb-2">
                <div class="flex-1 cursor-pointer" onclick="window.location.href='/media/${result.type}/${result.id}'">
                  <h3 class="font-semibold text-gray-900 dark:text-gray-100 line-clamp-2 mb-1 text-sm sm:text-base">${result.title}</h3>
                  <div class="flex flex-wrap items-center gap-1 sm:gap-2 mb-2">
                    <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${typeColors[result.type] || "bg-gray-100 text-gray-800"}">
                      ${typeLabels[result.type] || result.type}
                    </span>
                    ${result.year ? `<span class="text-xs sm:text-sm text-gray-500 dark:text-gray-400">${result.year}</span>` : ""}
                    ${
                      result.rating
                        ? `
                      <div class="flex items-center gap-1">
                        <svg class="w-3 h-3 sm:w-4 sm:h-4 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                        </svg>
                        <span class="text-xs sm:text-sm text-gray-600 dark:text-gray-400">${result.rating.toFixed(1)}</span>
                      </div>
                    `
                        : ""
                    }
                  </div>
                </div>
                <button 
                  class="add-to-list-btn ml-2 px-2 py-1 sm:px-3 sm:py-1 bg-blue-600 text-white text-xs sm:text-sm rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors duration-200 min-h-[44px] sm:min-h-auto"
                  data-media-id="${result.id}"
                  data-media-title="${result.title}"
                  data-media-type="${result.type}"
                  data-media-poster="${result.poster || ""}"
                  data-media-year="${result.year || ""}"
                  data-media-source="${result.source}"
                  onclick="event.stopPropagation()"
                  aria-label="Add ${result.title} to your list"
                >
                  Add
                </button>
              </div>
              ${result.description ? `<p class="text-xs sm:text-sm text-gray-600 dark:text-gray-400 line-clamp-2 sm:line-clamp-3 cursor-pointer" onclick="window.location.href='/media/${result.type}/${result.id}'">${result.description}</p>` : ""}
              <div class="mt-1 sm:mt-2 text-xs text-gray-400 dark:text-gray-500 capitalize">
                via ${result.source}
              </div>
            </div>
          </div>
        </div>
      `;

      // Add event listener for add to list functionality
      const addBtn = cardDiv.querySelector(
        ".add-to-list-btn"
      ) as HTMLButtonElement;
      if (addBtn) {
        addBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.handleAddToList(result, addBtn);
        });
      }

      return cardDiv;
    }

    private handleAddToList(result: SearchResult, button: HTMLButtonElement) {
      // Dispatch custom event for parent components to handle
      const addEvent = new CustomEvent("addToList", {
        detail: {
          id: result.id,
          title: result.title,
          type: result.type,
          poster: result.poster,
          year: result.year,
          source: result.source,
        },
        bubbles: true,
      });
      button.dispatchEvent(addEvent);

      // Visual feedback
      const originalText = button.textContent;
      button.textContent = "Added!";
      button.disabled = true;
      button.classList.remove("bg-blue-600", "hover:bg-blue-700");
      button.classList.add("bg-green-600");

      setTimeout(() => {
        button.textContent = originalText;
        button.disabled = false;
        button.classList.remove("bg-green-600");
        button.classList.add("bg-blue-600", "hover:bg-blue-700");
      }, 2000);
    }

    private async loadMore() {
      if (!this.hasMore || this.isLoading) return;
      await this.loadContent(this.currentPage + 1);
    }

    private retryLoad() {
      this.currentPage = 1;
      this.hasMore = true;
      this.data = [];

      if (this.sectionType === "recommended") {
        this.loadRecommendations();
      } else {
        this.loadContent();
      }
    }

    private showLoading(show: boolean) {
      const loading = this.container.querySelector(".section-loading");
      if (loading) {
        loading.classList.toggle("hidden", !show);
      }
    }

    private showGrid() {
      const grid = this.container.querySelector(".section-grid");
      if (grid) {
        grid.classList.remove("hidden");
      }
    }

    private showError(message: string) {
      const error = this.container.querySelector(".section-error");
      if (error) {
        error.classList.remove("hidden");
        const errorMessage = error.querySelector("p");
        if (errorMessage) {
          errorMessage.textContent = message;
        }
      }
    }

    private hideError() {
      const error = this.container.querySelector(".section-error");
      if (error) {
        error.classList.add("hidden");
      }
    }

    private showEmpty() {
      const empty = this.container.querySelector(".section-empty");
      if (empty) {
        empty.classList.remove("hidden");
      }
    }

    private hideEmpty() {
      const empty = this.container.querySelector(".section-empty");
      if (empty) {
        empty.classList.add("hidden");
      }
    }

    private showLoginPrompt() {
      const grid = this.container.querySelector(".section-grid");
      if (grid) {
        grid.innerHTML = `
          <div class="col-span-full">
            <div class="text-center py-12 bg-gray-50 dark:bg-gray-800 rounded-lg">
              <div class="text-gray-400 mb-4">
                <svg class="mx-auto h-12 w-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
              </div>
              <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100 mb-2">
                Login Required
              </h3>
              <p class="text-gray-500 dark:text-gray-400 mb-4">
                Sign in to see personalized recommendations based on your media lists.
              </p>
              <a 
                href="/login" 
                class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200"
              >
                Sign In
              </a>
            </div>
          </div>
        `;
        grid.classList.remove("hidden");
      }
      this.hideEmpty();
    }

    private updateInfiniteScroll() {
      const infiniteScrollWrapper = this.container.querySelector(
        ".infinite-scroll-wrapper"
      );

      if (infiniteScrollWrapper) {
        // Create or update the InfiniteScroll component
        infiniteScrollWrapper.innerHTML = `
          <div class="infinite-scroll-container">
            ${
              this.isLoading
                ? `
              <div class="flex justify-center items-center py-8" role="status" aria-live="polite">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" aria-hidden="true"></div>
                <span class="ml-2 text-gray-600 dark:text-gray-400">Loading more...</span>
              </div>
            `
                : ""
            }
            
            ${
              this.hasMore && !this.isLoading
                ? `
              <div class="load-more-trigger" data-threshold="200" data-auto-load="true">
                <button 
                  class="load-more-btn w-full py-3 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                  onclick="loadMoreSection_${this.sectionId}()"
                  aria-label="Load more content"
                >
                  Load More
                </button>
              </div>
            `
                : ""
            }
            
            ${
              !this.hasMore && !this.isLoading && this.data.length > 0
                ? `
              <div class="text-center py-8 text-gray-500 dark:text-gray-400" role="status">
                <p>You've reached the end of the results</p>
              </div>
            `
                : ""
            }
          </div>
        `;

        // Set up intersection observer for the new load more trigger
        if (this.hasMore && !this.isLoading) {
          const loadMoreTrigger =
            infiniteScrollWrapper.querySelector(".load-more-trigger");
          if (loadMoreTrigger && window.IntersectionObserver) {
            const observer = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  if (entry.isIntersecting && !this.isLoading) {
                    this.loadMore();
                  }
                });
              },
              {
                rootMargin: "200px 0px",
                threshold: 0.01,
              }
            );

            observer.observe(loadMoreTrigger);

            // Store observer for cleanup
            (loadMoreTrigger as any)._observer = observer;
          }
        }
      }
    }
  }

  // Initialize content sections when DOM is loaded
  document.addEventListener("DOMContentLoaded", () => {
    const sections = document.querySelectorAll(".content-section");
    sections.forEach((section) => {
      new ContentSection(section as HTMLElement);
    });
  });

  // Export for external use
  (window as any).ContentSection = ContentSection;
</script>
